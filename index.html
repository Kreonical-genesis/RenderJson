<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RenderJson</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <style>
        :root {
            --bg-base: #0f1115;
            --bg-panel: #1a1c23;
            --bg-input: #272a35;
            --border-color: #2e323f;
            --accent: #6366f1;
            --accent-hover: #4f46e5;
            --text-main: #f3f4f6;
            --text-dim: #9ca3af;
            --success: #10b981;
            --error: #ef4444;
            --radius: 6px;
        }
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body { 
            background: var(--bg-base); 
            color: var(--text-main); 
            font-family: 'Inter', 'Segoe UI', system-ui, sans-serif; 
            height: 100vh; 
            display: flex; 
            flex-direction: column;
            overflow: hidden;
        }

        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-panel); }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }

        input, select, button { font-family: inherit; }
        
        button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: var(--radius);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        button:hover:not(:disabled) { background: var(--accent-hover); transform: translateY(-1px); }
        button:disabled { background: #374151; color: #9ca3af; cursor: not-allowed; transform: none; }
        
        input[type="text"], input[type="number"], select {
            width: 100%;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            color: var(--text-main);
            padding: 10px 12px;
            border-radius: var(--radius);
            outline: none;
            transition: border-color 0.2s;
        }
        
        select[multiple] {
            padding: 4px;
            height: 150px;
        }
        select[multiple] option {
            padding: 6px 10px;
            margin-bottom: 2px;
            border-radius: 4px;
            cursor: pointer;
        }
        select[multiple] option:checked {
            background: var(--accent);
            color: white;
        }

        input:focus, select:focus { border-color: var(--accent); }

        header {
            height: 60px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 20px;
            justify-content: space-between;
            flex-shrink: 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 20;
        }
        
        .brand-area { display: flex; align-items: center; gap: 15px; }
        .header-title { font-weight: 700; color: #fff; font-size: 1.2em; letter-spacing: 0.5px; }

        .mode-badge {
            font-size: 0.75rem;
            color: white;
            padding: 4px 10px;
            border-radius: 4px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: background-color 0.3s;
        }
        .mode-badge.setup { background-color: #4b5563; }
        .mode-badge.gif { background-color: #d97706; }
        .mode-badge.png { background-color: var(--accent); }

        #status-area {
            display: flex;
            align-items: center;
            flex: 1;
            margin-left: 40px;
            gap: 20px;
            justify-content: flex-end; 
        }

        .status-info { display: flex; flex-direction: column; align-items: flex-end; min-width: 120px; }
        #status-text { white-space: nowrap; font-size: 0.95rem; font-weight: 600; color: #eee; }
        #eta-text { font-size: 0.8rem; color: var(--text-dim); margin-top: 2px; font-family: 'Consolas', monospace; }

        #progress-track {
            flex: 0 1 400px; 
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            display: none;
        }
        #progress-bar {
            width: 0%;
            height: 100%;
            background: var(--success);
            transition: width 0.3s ease-out;
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.4);
        }

        #main-view {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .panel-header {
            padding: 12px 15px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid var(--border-color);
            font-size: 0.85rem;
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 0.05em;
            color: var(--text-dim);
            flex-shrink: 0;
        }

        .form-group { display: flex; flex-direction: column; gap: 8px; }
        .form-group label { font-size: 0.9rem; color: var(--text-dim); font-weight: 500; }
        
        .disabled-panel { opacity: 0.5; pointer-events: none; filter: grayscale(30%); transition: all 0.3s; }

        .sidebar-setup {
            width: 300px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            z-index: 10;
        }

        .tech-panel {
            display: flex;
            flex-direction: column;
            border-bottom: 1px solid var(--border-color);
        }
        .panel-content {
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .sidebar-models {
            width: 380px;
            background: var(--bg-base);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .list-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .list-header span { font-size: 0.85rem; color: var(--text-dim); }
        .list-actions button { background: transparent; border: 1px solid var(--border-color); color: var(--text-main); padding: 4px 8px; font-size: 0.8rem; }
        .list-actions button:hover { background: var(--bg-input); }
        
        .model-list-container {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .model-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.1s;
            background: rgba(255,255,255,0.02);
            border: 1px solid rgba(255,255,255,0.05);
            margin-bottom: 6px;
        }
        .model-item:hover { background: rgba(255,255,255,0.05); border-color: rgba(255,255,255,0.1); }
        .model-item input[type="checkbox"] { width: 16px; height: 16px; cursor: pointer; accent-color: var(--accent); }
        .model-item span { font-size: 0.85rem; word-break: break-all; }

        .render-workspace {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #000;
            min-width: 0;
        }

        #render-section {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden; 
            padding: 20px;
        }
        
        #canvas-wrapper {
            background-image: linear-gradient(45deg, #111 25%, transparent 25%), linear-gradient(-45deg, #111 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #111 75%), linear-gradient(-45deg, transparent 75%, #111 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            border: 1px solid var(--border-color);
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            display: flex; 
        }
        
        #canvas-container canvas {
            display: block;
            max-width: 100%; 
            max-height: 100%; 
            height: auto !important; 
            width: auto !important;
        }

        #log-section {
            height: 250px;
            background: var(--bg-panel);
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        #log-container {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
        }
        
        .log-entry { 
            margin-bottom: 6px; 
            word-break: break-all; 
            line-height: 1.4;
            border-bottom: 1px solid rgba(255,255,255,0.03);
            padding-bottom: 4px;
        }
        .log-entry span.time { color: var(--text-dim); font-size: 0.9em; margin-right: 8px; }
        .log-entry.success { color: var(--success); } 
        .log-entry.error { color: var(--error); }
        .log-entry.normal { color: #d1d5db; }

        @media (max-width: 1100px) {
            #main-view { flex-direction: column; overflow-y: auto; }
            .sidebar-setup, .sidebar-models { width: 100%; border-right: none; border-bottom: 1px solid var(--border-color); }
            .sidebar-models { height: 400px; flex-shrink: 0; }
            .render-workspace { height: 800px; flex-shrink: 0; }
        }
    </style>
</head>
<body>
    
    <header>
        <div class="brand-area">
            <div class="header-title">RenderJson</div>
            <div id="mode-badge" class="mode-badge setup">ОЖИДАНИЕ</div>
        </div>
        <div id="status-area">
            <div class="status-info">
                <div id="status-text" style="color: var(--text-main); font-weight: normal; font-size: 0.95rem;">Готов к работе</div>
                <div id="eta-text">by kreo_gen & mrlemonhog</div>
            </div>
            <div id="progress-track"><div id="progress-bar"></div></div>
        </div>
    </header>

    <main id="main-view">
        <aside class="sidebar-setup" id="step-1-2">
            
            <div class="tech-panel">
                <div class="panel-header">1. Ресурспак</div>
                <div class="panel-content">
                    <div class="form-group">
                        <label>Выберите .zip архив(ы) из /import</label>
                        <div style="font-size: 0.75rem; color: var(--text-dim); margin-top: -4px;">Зажмите Ctrl/Shift для выбора нескольких</div>
                        <select id="pack-select" multiple title="Используйте Ctrl / Shift для выделения нескольких">
                            <option value="">Загрузка...</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="tech-panel" id="settings-card" style="flex: 1;">
                <div class="panel-header">2. Настройки рендера</div>
                <div class="panel-content">
                    <div class="form-group">
                        <label>Режим</label>
                        <select id="setting-mode">
                            <option value="png">PNG</option>
                            <option value="gif">GIF</option>
                        </select>
                    </div>
                    <div class="form-group" style="margin-top: 5px;">
                        <label>Разрешение (px)</label>
                        <input type="number" id="setting-size" value="800" min="100" max="2048">
                    </div>
                </div>
            </div>
            
            <div style="padding: 15px; border-top: 1px solid var(--border-color); background: var(--bg-panel); margin-top: auto; display: flex; justify-content: center;">
                <button id="btn-extract" disabled style="width: 100%; padding: 12px 0; font-size: 1.05rem;">
                    <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                    Распаковать архив
                </button>
            </div>
        </aside>

        <section class="sidebar-models disabled-panel" id="step-3">
            <div class="panel-header" style="display: flex; justify-content: space-between; align-items: center;">
                <span>3. Выбор моделей</span>
                <span id="models-count-text" style="font-size: 0.85rem; font-weight: normal; color: var(--text-dim); text-transform: none;">Выбрано: 0 / 0</span>
            </div>
            
            <div style="padding: 15px; border-bottom: 1px solid var(--border-color); background: var(--bg-panel);">
                <div class="form-group">
                    <input type="text" id="model-search" placeholder="Поиск по названию или пути..." oninput="filterModels()">
                </div>
                <div class="list-header" style="margin-top: 15px; margin-bottom: 0;">
                    <span>Список найденных файлов:</span>
                    <div class="list-actions">
                        <button onclick="toggleAllModels(true)">Все</button>
                        <button onclick="toggleAllModels(false)">Сброс</button>
                    </div>
                </div>
            </div>
            
            <div class="model-list-container" id="model-list">
            </div>
            
            <div style="padding: 15px; border-top: 1px solid var(--border-color); background: var(--bg-panel); display: flex; justify-content: center;">
                <button id="btn-start" class="disabled-panel" onclick="startBatchProcess()" style="background: var(--success); padding: 12px 0; width: 100%; font-size: 1.05rem;">
                    Начать Рендер
                    <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg>
                </button>
            </div>
        </section>

        <section class="render-workspace">
            <div id="render-section">
                <div id="canvas-wrapper">
                    <div id="canvas-container"></div>
                </div>
            </div>
            
            <div id="log-section">
                <div class="panel-header" style="background: transparent;">Логи процесса</div>
                <div id="log-container">
                    <div class="log-entry normal"><span class="time"></span>Система готова. Ожидание распаковки пака...</div>
                </div>
            </div>
        </section>
    </main>

    <script>
        let availableModels = [];
        let selectedModels = new Set();
        
        let RENDER_MODE = "png";
        let CANVAS_SIZE = 800; 
        let modelsToRender = [];

        let scene, camera, renderer, mesh, rotationWrapper;

        window.onload = async () => {
            try {
                const res = await fetch('/api/packs');
                const data = await res.json();
                const select = document.getElementById('pack-select');
                select.innerHTML = '';
                
                if (data.packs.length === 0) {
                    select.innerHTML = '<option disabled selected>Папка /import пуста</option>';
                    document.getElementById('btn-extract').disabled = true;
                } else {
                    data.packs.forEach(p => {
                        select.innerHTML += `<option value="${p}">${p}</option>`;
                    });
                    select.addEventListener('change', handlePackSelectionChange);
                    handlePackSelectionChange();
                }
            } catch (e) {
                alert("Ошибка связи с сервером. Проверьте консоль.");
            }
        };

        function handlePackSelectionChange() {
            const select = document.getElementById('pack-select');
            const selected = Array.from(select.selectedOptions).filter(o => o.value !== "");
            const btn = document.getElementById('btn-extract');
            
            if (selected.length === 0) {
                btn.disabled = true;
                btn.innerHTML = `<svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg> Распаковать архив`;
                return;
            }
            btn.disabled = false;

            if (selected.length > 1) {
                btn.innerHTML = `<svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 002-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path></svg> Авто-рендер всех (${selected.length})`;
                btn.onclick = () => startMultiPackBatch(selected.map(o => o.value));
                document.getElementById('step-3').classList.add('disabled-panel');
            } else {
                btn.innerHTML = `<svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg> Распаковать архив`;
                btn.onclick = () => extractPack();
            }
        }

        async function extractPack() {
            const select = document.getElementById('pack-select');
            if (select.selectedOptions.length === 0) return;
            const pack = select.selectedOptions[0].value;

            const btn = document.getElementById('btn-extract');
            btn.innerHTML = '<svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg> Распаковка...';
            btn.disabled = true;

            try {
                const res = await fetch('/api/extract', {
                    method: 'POST',
                    body: JSON.stringify({ pack })
                });
                const data = await res.json();
                
                availableModels = data.models || [];
                selectedModels = new Set(availableModels);
                
                renderModelList();
                
                btn.innerHTML = '✔ Загружено';
                document.getElementById('step-3').classList.remove('disabled-panel');
                document.getElementById('btn-start').classList.remove('disabled-panel');
                
                log(`Пак ${pack} успешно распакован. Найдено моделей: ${availableModels.length}`, 'success');

                setTimeout(() => handlePackSelectionChange(), 2000);

            } catch(e) {
                alert("Ошибка при распаковке архива.");
                handlePackSelectionChange();
                log(`Ошибка распаковки: ${e.message}`, 'error');
            }
        }

        function filterModels() {
            const query = document.getElementById('model-search').value.toLowerCase();
            renderModelList(query);
        }

        function toggleAllModels(state) {
            const query = document.getElementById('model-search').value.toLowerCase();
            const visibleModels = availableModels.filter(m => m.toLowerCase().includes(query));
            
            if (state) {
                visibleModels.forEach(m => selectedModels.add(m));
            } else {
                visibleModels.forEach(m => selectedModels.delete(m));
            }
            renderModelList(query);
        }

        function updateSelectedCount() {
            document.getElementById('models-count-text').textContent = `Выбрано: ${selectedModels.size} / ${availableModels.length}`;
            const btnStart = document.getElementById('btn-start');
            if(selectedModels.size === 0) {
                btnStart.disabled = true;
                btnStart.textContent = "Выберите модели";
            } else {
                btnStart.disabled = false;
                btnStart.innerHTML = `Начать Рендер (${selectedModels.size}) <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg>`;
            }
        }

        function renderModelList(filter = "") {
            const list = document.getElementById('model-list');
            list.innerHTML = '';
            
            const frag = document.createDocumentFragment();
            const filtered = filter ? availableModels.filter(m => m.toLowerCase().includes(filter)) : availableModels;

            filtered.forEach(m => {
                const label = document.createElement('label');
                label.className = 'model-item';
                
                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.value = m;
                cb.checked = selectedModels.has(m);
                cb.onchange = (e) => {
                    if (e.target.checked) selectedModels.add(m);
                    else selectedModels.delete(m);
                    updateSelectedCount();
                };

                const span = document.createElement('span');
                span.textContent = m.replace('temp_pack/assets/', '');

                label.appendChild(cb);
                label.appendChild(span);
                frag.appendChild(label);
            });
            
            list.appendChild(frag);
            updateSelectedCount();
        }

        function initScene() {
            if (renderer) return; 
            
            scene = new THREE.Scene();
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 1000);
            
            const distance = 50;
            const angleY = 225 * Math.PI / 180;
            const angleX = 30 * Math.PI / 180;
            
            camera.position.set(
                distance * Math.sin(angleY) * Math.cos(angleX),
                distance * Math.sin(angleX),
                distance * Math.cos(angleY)
            );
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true, 
                preserveDrawingBuffer: true,
                logarithmicDepthBuffer: true
            });
            renderer.setSize(CANVAS_SIZE, CANVAS_SIZE);
            renderer.setClearColor(0x000000, 0);
            renderer.sortObjects = true;
            
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            scene.add(new THREE.AmbientLight(0xffffff, 0.9));
            const topLight = new THREE.DirectionalLight(0xffffff, 0.5);
            topLight.position.set(5, 20, 5);
            scene.add(topLight);
        }

        function fitCameraToMesh(targetMesh) {
            const box = new THREE.Box3().setFromObject(targetMesh);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            if (rotationWrapper) {
                rotationWrapper.position.set(-center.x, -center.y, -center.z);
            } else {
                targetMesh.position.x -= center.x;
                targetMesh.position.y -= center.y;
                targetMesh.position.z -= center.z;
            }

            const maxDim = Math.max(size.x, size.y, size.z);
            camera.zoom = (2 / (maxDim || 1)) * 0.8; 
            camera.updateProjectionMatrix();
        }

        function resolveTextureUrl(texturePath) {
            let namespace = 'minecraft';
            let path = texturePath;
            if (texturePath.includes(':')) {
                const parts = texturePath.split(':');
                namespace = parts[0];
                path = parts[1];
            }
            return `temp_pack/assets/${namespace}/textures/${path}.png`;
        }

        async function loadModelTextures(model) {
            const textureMap = {};
            const loader = new THREE.TextureLoader();
            
            if (!model.textures) return {};

            let contextDir = "";
            let contextNamespace = "minecraft";

            for(let k in model.textures) {
                const t = model.textures[k];
                if(t && typeof t === 'string' && !t.startsWith('#') && !t.startsWith('items_displayed:') && t.includes('/')) {
                     const parts = t.split(':');
                     if (parts.length > 1) {
                         contextNamespace = parts[0];
                         const p = parts[1];
                         contextDir = p.substring(0, p.lastIndexOf('/')+1);
                     } else {
                         contextNamespace = 'minecraft';
                         const p = parts[0];
                         contextDir = p.substring(0, p.lastIndexOf('/')+1);
                     }
                     break; 
                }
            }

            const resolveRef = (key) => {
                let val = model.textures[key];
                let attempts = 0;
                while (val && val.startsWith('#') && attempts < 10) {
                    val = model.textures[val.substring(1)];
                    attempts++;
                }
                return val;
            };

            const promises = [];
            for (let key in model.textures) {
                const finalPath = resolveRef(key);
                if (finalPath) {
                    let url;
                    if (finalPath.startsWith('items_displayed:')) {
                        const cleanName = finalPath.split(':')[1];
                        const fullPath = contextNamespace + ":" + contextDir + cleanName;
                        url = resolveTextureUrl(fullPath);
                    } else {
                        url = resolveTextureUrl(finalPath);
                    }

                    promises.push(new Promise((resolve) => {
                        loader.load(url, (tex) => {
                            tex.magFilter = THREE.NearestFilter;
                            tex.minFilter = THREE.NearestFilter;
                            tex.colorSpace = THREE.SRGBColorSpace;
                            textureMap['#' + key] = tex;
                            resolve();
                        }, undefined, () => {
                            resolve();
                        });
                    }));
                }
            }
            await Promise.all(promises);
            return textureMap;
        }
        
        async function loadModelWithParents(modelPath, depth = 0) {
            if (depth > 10) throw new Error("limit reached");

            const response = await fetch(modelPath);
            if (!response.ok) throw new Error("Model not found");
            const model = await response.json();

            if (
                model.parent === "item/generated" ||
                model.parent === "minecraft:item/generated"
            ) {
                return model;
            }

            if (!model.parent) return model;

            let parentPath;
            const parent = model.parent;

            if (parent.includes(":")) {
                const [namespace, path] = parent.split(":");
                parentPath = `temp_pack/assets/${namespace}/models/${path}.json`;
            } else {
                parentPath = `temp_pack/assets/minecraft/models/${parent}.json`;
            }

            const parentModel = await loadModelWithParents(parentPath, depth + 1);

            return {
                ...parentModel,
                ...model,
                textures: {
                    ...(parentModel.textures || {}),
                    ...(model.textures || {})
                }
            };
        }

        async function createGeneratedModel(model) {
            const group = new THREE.Group();
            const textureMap = await loadModelTextures(model);

            for (let i = 0; i < 5; i++) {
                const layerKey = "layer" + i;
                const tex = textureMap["#" + layerKey];
                if (!tex) break;

                const image = tex.image;
                const canvas = document.createElement("canvas");
                canvas.width = image.width;
                canvas.height = image.height;

                const ctx = canvas.getContext("2d");
                ctx.drawImage(image, 0, 0);

                const imageData = ctx.getImageData(0, 0, image.width, image.height);
                const data = imageData.data;

                for (let y = 0; y < image.height; y++) {
                    for (let x = 0; x < image.width; x++) {
                        const index = (y * image.width + x) * 4;
                        const alpha = data[index + 3];
                        if (alpha < 10) continue;

                        const pixelCanvas = document.createElement('canvas');
                        pixelCanvas.width = 1;
                        pixelCanvas.height = 1;
                        const ctx = pixelCanvas.getContext('2d');
                        ctx.putImageData(new ImageData(new Uint8ClampedArray([
                            data[index], data[index+1], data[index+2], data[index+3]
                        ]), 1, 1), 0, 0);

                        const pixelTex = new THREE.CanvasTexture(pixelCanvas);
                        pixelTex.magFilter = THREE.NearestFilter;
                        pixelTex.minFilter = THREE.NearestFilter;

                        const geometry = new THREE.BoxGeometry(1 / image.width, 1 / image.height, 0.0625);

                        const material = new THREE.MeshStandardMaterial({
                            map: pixelTex,
                            transparent: true,
                            alphaTest: 0.05,
                            side: THREE.DoubleSide
                        });

                        const mesh = new THREE.Mesh(geometry, material);

                        mesh.position.x = x / image.width - 0.5 + 0.5 / image.width;
                        mesh.position.y = 0.5 - y / image.height - 0.5 / image.height;
                        mesh.position.z = 0;

                        group.add(mesh);
                    }
                }
            }
            return group;
        }

        async function createGeometryFromModel(model) {
            const textureMap = await loadModelTextures(model);
            const group = new THREE.Group();
            const transparentMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, depthWrite: false, depthTest: false });

            const EPS = 0.002;
            let renderOrderCounter = 0;
            const processedSignatures = new Set();

            if (model.elements) {
                model.elements.forEach(element => {
                    const rawFrom = element.from;
                    const rawTo   = element.to;

                    const mirrorX = rawFrom[0] > rawTo[0];
                    const mirrorY = rawFrom[1] > rawTo[1];
                    const mirrorZ = rawFrom[2] > rawTo[2];

                    const from = [
                        Math.min(rawFrom[0], rawTo[0]),
                        Math.min(rawFrom[1], rawTo[1]),
                        Math.min(rawFrom[2], rawTo[2])
                    ];
                    const to = [
                        Math.max(rawFrom[0], rawTo[0]),
                        Math.max(rawFrom[1], rawTo[1]),
                        Math.max(rawFrom[2], rawTo[2])
                    ];

                    const faceSig = element.faces ? JSON.stringify(element.faces) : '';
                    const sig = `${from.join(',')}|${to.join(',')}|${mirrorX}${mirrorY}${mirrorZ}|${faceSig}`;
                    if (processedSignatures.has(sig)) return; 
                    processedSignatures.add(sig);

                    const sizeX = (to[0] - from[0]) / 16;
                    const sizeY = (to[1] - from[1]) / 16;
                    const sizeZ = (to[2] - from[2]) / 16;

                    const geometry = new THREE.BoxGeometry(
                        Math.max(sizeX, 0.0001) + EPS, 
                        Math.max(sizeY, 0.0001) + EPS, 
                        Math.max(sizeZ, 0.0001) + EPS
                    );

                    const uvAttr = new THREE.BufferAttribute(new Float32Array(geometry.attributes.uv.array), 2);
                    geometry.setAttribute('uv', uvAttr);
                    const uvs = uvAttr.array;

                    const materials = [];
                    const faceOrder = ['east', 'west', 'up', 'down', 'south', 'north'];

                    if (element.faces) {
                        faceOrder.forEach((faceName, index) => {
                            const face = element.faces[faceName];
                            let assignedMat = transparentMat;
                            
                            if (face && face.texture) {
                                const tex = textureMap[face.texture];
                                if (tex) {
                                    assignedMat = new THREE.MeshStandardMaterial({
                                        map: tex,
                                        transparent: true,
                                        alphaTest: 0.05,
                                        side: THREE.DoubleSide,
                                        depthWrite: true,
                                        depthTest: true,
                                        polygonOffset: true,
                                        polygonOffsetFactor: -renderOrderCounter * 0.1,
                                        polygonOffsetUnits: -1,
                                    });
                                }
                            }
                            materials.push(assignedMat);

                            if (face && face.uv) {
                                const uv = face.uv;
                                let u1 = uv[0] / 16;
                                let u2 = uv[2] / 16;
                                let v1 = 1 - (uv[1] / 16);
                                let v2 = 1 - (uv[3] / 16);

                                let flipU = false;
                                let flipV = false;
                                if (faceName === 'east' || faceName === 'west') {
                                    if (mirrorZ) flipU = !flipU;
                                    if (mirrorY) flipV = !flipV;
                                    if (mirrorX) { flipU = !flipU; flipV = !flipV; } 
                                } else if (faceName === 'up' || faceName === 'down') {
                                    if (mirrorX) flipU = !flipU;
                                    if (mirrorZ) flipV = !flipV;
                                } else if (faceName === 'south' || faceName === 'north') {
                                    if (mirrorX) flipU = !flipU;
                                    if (mirrorY) flipV = !flipV;
                                    if (mirrorZ) { flipU = !flipU; flipV = !flipV; }
                                }

                                if (flipU) { const tmp = u1; u1 = u2; u2 = tmp; }
                                if (flipV) { const tmp = v1; v1 = v2; v2 = tmp; }

                                const corners = [{ u: u1, v: v1 }, { u: u2, v: v1 }, { u: u1, v: v2 }, { u: u2, v: v2 }];

                                let rotation = face.rotation || 0;
                                let mapOrder = [0, 1, 2, 3];
                                if (rotation === 90)  mapOrder = [2, 0, 3, 1];
                                if (rotation === 180) mapOrder = [3, 2, 1, 0];
                                if (rotation === 270) mapOrder = [1, 3, 0, 2];

                                const offset = index * 8;
                                uvs[offset] = corners[mapOrder[0]].u; uvs[offset + 1] = corners[mapOrder[0]].v;
                                uvs[offset + 2] = corners[mapOrder[1]].u; uvs[offset + 3] = corners[mapOrder[1]].v;
                                uvs[offset + 4] = corners[mapOrder[2]].u; uvs[offset + 5] = corners[mapOrder[2]].v;
                                uvs[offset + 6] = corners[mapOrder[3]].u; uvs[offset + 7] = corners[mapOrder[3]].v;
                            } else {
                                const offset = index * 8;
                                for(let i=0; i<8; i++) uvs[offset+i] = 0;
                            }
                        });
                        geometry.attributes.uv.needsUpdate = true;
                    } else {
                        for(let i=0; i<6; i++) materials.push(transparentMat);
                    }

                    const cube = new THREE.Mesh(geometry, materials);
                    cube.renderOrder = renderOrderCounter++;
                    const posX = ((from[0] + to[0]) / 2) / 16 - 0.5;
                    const posY = ((from[1] + to[1]) / 2) / 16 - 0.5;
                    const posZ = ((from[2] + to[2]) / 2) / 16 - 0.5;
                    cube.position.set(posX, posY, posZ);

                    if (element.rotation) {
                        const origin = element.rotation.origin;
                        const axis = element.rotation.axis;
                        const angle = (element.rotation.angle || 0) * (Math.PI / 180);
                        
                        const pivotX = origin[0] / 16 - 0.5;
                        const pivotY = origin[1] / 16 - 0.5;
                        const pivotZ = origin[2] / 16 - 0.5;

                        const pivotGroup = new THREE.Group();
                        pivotGroup.position.set(pivotX, pivotY, pivotZ);
                        group.add(pivotGroup);

                        cube.position.set(posX - pivotX, posY - pivotY, posZ - pivotZ);
                        pivotGroup.add(cube);

                        if (axis === 'x') pivotGroup.rotation.x = angle;
                        else if (axis === 'y') pivotGroup.rotation.y = angle;
                        else if (axis === 'z') pivotGroup.rotation.z = angle;
                    } else {
                        group.add(cube);
                    }
                });
            }
            return group;
        }

        async function renderItem(modelPath) {
            let modelData;
            try {
                modelData = await loadModelWithParents(modelPath);
            } catch (e) {
                throw new Error(`Load error: ${e.message}`);
            }

            if (mesh) {
                scene.remove(mesh);
                mesh.traverse(obj => {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) {
                        if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
                        else obj.material.dispose();
                    }
                });
                mesh = null;
            }

            if (rotationWrapper) {
                scene.remove(rotationWrapper);
                rotationWrapper = null;
            }

            if (modelData.parent === "item/generated" || !modelData.elements) {
                mesh = await createGeneratedModel(modelData);
                rotationWrapper = new THREE.Group();
                rotationWrapper.add(mesh);
                scene.add(rotationWrapper);
                fitCameraToMesh(mesh);
            } else {
                mesh = await createGeometryFromModel(modelData);
                rotationWrapper = new THREE.Group();
                rotationWrapper.add(mesh);
                scene.add(rotationWrapper);
                fitCameraToMesh(mesh);
            }

            if (RENDER_MODE === "png") {
                renderer.render(scene, camera);
                return renderer.domElement.toDataURL("image/png");
            }

            if (RENDER_MODE === "gif") {
                return await renderGif();
            }
        }

        async function renderGif() {
            rotationWrapper.rotation.set(0, 0, 0);
            return new Promise((resolve) => {
                const gif = new GIF({
                    workers: 2,
                    quality: 1,
                    width: CANVAS_SIZE,
                    height: CANVAS_SIZE,
                    workerScript: "gif.worker.js",
                    transparent: 0x000000
                });

                const frames = 60;
                const fullRotation = Math.PI * 2;
                let currentFrame = 0;

                function captureFrame() {
                    rotationWrapper.rotation.y = (currentFrame / frames) * fullRotation;
                    renderer.render(scene, camera);
                    gif.addFrame(renderer.domElement, { copy: true, delay: 40 });
                    currentFrame++;

                    if (currentFrame < frames) {
                        requestAnimationFrame(captureFrame);
                    } else {
                        gif.on("finished", function(blob) {
                            const reader = new FileReader();
                            reader.onload = () => resolve(reader.result);
                            reader.readAsDataURL(blob);
                        });
                        gif.render();
                    }
                }
                captureFrame();
            });
        }

        const log = (msg, type='normal') => {
            const div = document.createElement('div');
            const time = new Date().toLocaleTimeString('ru-RU', {hour12: false, hour: '2-digit', minute:'2-digit', second:'2-digit'});
            div.innerHTML = `<span class="time">[${time}]</span>${msg}`;
            div.className = 'log-entry ' + type;
            document.getElementById('log-container').prepend(div);
        };

        const updateStatus = (text, percent, etaText = "") => {
            document.getElementById('status-text').textContent = text;
            if (etaText) document.getElementById('eta-text').textContent = etaText;
            document.getElementById('progress-bar').style.width = percent + '%';
        };

        async function runRenderLoop(modelsList, packName = "") {
            let total = modelsList.length;
            let processed = 0;
            const startTime = Date.now();

            for (let modelPath of modelsList) {
                processed++;
                const now = Date.now();
                const elapsed = now - startTime;
                const avgTimePerItem = elapsed / processed;
                const remainingItems = total - processed;
                const etaMs = avgTimePerItem * remainingItems;
                
                let etaString = "--:--";
                if (processed > 0) {
                    const totalSeconds = Math.floor(etaMs / 1000);
                    const minutes = Math.floor(totalSeconds / 60);
                    const seconds = totalSeconds % 60;
                    etaString = `${minutes}m ${seconds.toString().padStart(2, '0')}s`;
                }

                const prefix = packName ? `[${packName}] ` : "";
                updateStatus(`${prefix}Рендер ${processed} из ${total}`, (processed/total)*100, `Осталось: ~${etaString}`);

                try {
                    const base64Image = await renderItem(modelPath);

                    let cleanId = modelPath.replace('temp_pack/assets/', '').replace(".json", "");
                    
                    if (packName) {
                        const pName = packName.replace('.zip', '');
                        cleanId = `${pName}/${cleanId}`;
                    }
                    
                    await fetch('/upload_image', {
                        method: 'POST',
                        body: JSON.stringify({ 
                            id: cleanId,
                            image: base64Image,
                            mode: RENDER_MODE
                        })
                    });

                    log(`Успешно: ${cleanId}`, "success");
                } catch (e) {
                    log(`Ошибка (${modelPath}): ${e.message}`, "error");
                }

                await new Promise(r => setTimeout(r, 30));
            }
        }

        async function startBatchProcess() {
            RENDER_MODE = document.getElementById('setting-mode').value;
            CANVAS_SIZE = parseInt(document.getElementById('setting-size').value) || 800;
            modelsToRender = Array.from(selectedModels);

            document.getElementById('step-1-2').classList.add('disabled-panel');
            document.getElementById('step-3').classList.add('disabled-panel');

            const badge = document.getElementById('mode-badge');
            badge.textContent = (RENDER_MODE === 'gif' ? 'GIF' : 'IMG') + ' MODE';
            badge.className = 'mode-badge ' + (RENDER_MODE === 'gif' ? 'gif' : 'png');

            document.getElementById('progress-track').style.visibility = 'visible';
            document.getElementById('progress-bar').style.width = '0%';
            document.getElementById('progress-bar').style.background = 'var(--success)';
            document.getElementById('log-container').innerHTML = '';

            initScene();
            if (renderer) renderer.setSize(CANVAS_SIZE, CANVAS_SIZE);
            
            log(`Начат рендер ${modelsToRender.length} файлов...`);
            
            const select = document.getElementById('pack-select');
            const packName = select.selectedOptions.length > 0 ? select.selectedOptions[0].value : "";

            await runRenderLoop(modelsToRender, packName);

            updateStatus('Готово', 100, 'Завершено');
            document.getElementById('progress-bar').style.background = '#10b981';
            log('Все задачи завершены!', 'success');
            
            document.getElementById('step-1-2').classList.remove('disabled-panel');
            document.getElementById('step-3').classList.remove('disabled-panel');
        }

        async function startMultiPackBatch(packs) {
            RENDER_MODE = document.getElementById('setting-mode').value;
            CANVAS_SIZE = parseInt(document.getElementById('setting-size').value) || 800;
            
            document.getElementById('step-1-2').classList.add('disabled-panel');
            document.getElementById('step-3').classList.add('disabled-panel');
            
            const badge = document.getElementById('mode-badge');
            badge.textContent = (RENDER_MODE === 'gif' ? 'GIF' : 'IMG') + ' BATCH';
            badge.className = 'mode-badge ' + (RENDER_MODE === 'gif' ? 'gif' : 'png');

            document.getElementById('progress-track').style.visibility = 'visible';
            document.getElementById('progress-bar').style.width = '0%';
            document.getElementById('progress-bar').style.background = 'var(--success)';
            document.getElementById('log-container').innerHTML = '';

            initScene();
            if (renderer) renderer.setSize(CANVAS_SIZE, CANVAS_SIZE);
            
            log(`Начат автоматический пакетный рендер ${packs.length} ресурспаков...`, 'success');

            for (let i = 0; i < packs.length; i++) {
                const pack = packs[i];
                log(`[${i+1}/${packs.length}] Распаковка ${pack}...`);
                updateStatus(`Распаковка ${pack}...`, (i / packs.length) * 100, `Ожидание`);
                
                try {
                    const res = await fetch('/api/extract', {
                        method: 'POST',
                        body: JSON.stringify({ pack })
                    });
                    const data = await res.json();
                    const models = data.models || [];
                    
                    if (models.length === 0) {
                         log(`[${pack}] Нет моделей для рендера. Пропуск.`, 'normal');
                         continue;
                    }

                    log(`[${pack}] Найдено ${models.length} моделей. Запуск рендера...`);
                    await runRenderLoop(models, pack);

                } catch (e) {
                    log(`[${pack}] Ошибка распаковки: ${e.message}`, 'error');
                }
            }

            updateStatus('Готово', 100, 'Все паки завершены');
            document.getElementById('progress-bar').style.background = '#10b981';
            log('Пакетный рендер всех выбранных паков завершен!', 'success');
            
            document.getElementById('step-1-2').classList.remove('disabled-panel');
        }
    </script>
</body>
</html>